#include "auto_f2c.h"
/*==========================================================================
 *  Code generated by the Maple script autocode.mpl 
 *
 *  Dependent variables: [phi[1], phi[2], phi[3]]
 *  Parameters:          [omega]
 *  The vector field given in Maple was
 *     f[1] = 3*tan(phi[1])-omega^2*(3*sin(phi[1])+2*sin(phi[2])+sin(phi[3]))
 *     f[2] = 2*tan(phi[2])-omega^2*(2*sin(phi[1])+2*sin(phi[2])+sin(phi[3]))
 *     f[3] = tan(phi[3])-omega^2*(sin(phi[1])+sin(phi[2])+sin(phi[3]))
 *  Remember that Maple starts its indices at 1, while C starts at 0.
 *==========================================================================
 */

/*--------------------------------------------------------------------------*/
/* FUNC  Defines the vector field.                                          */
/*--------------------------------------------------------------------------*/

int func(integer ndim, const doublereal *u, const integer *icp, 
         const doublereal *par, integer ijac, 
         doublereal *f, doublereal *dfdu, doublereal *dfdp)
{
      integer dfdu_dim1, dfdp_dim1;
      doublereal jacob[3][3];
      doublereal dfdpar[3][1];

      doublereal phi[3];
      doublereal omega;

      dfdu_dim1 = ndim;
      dfdp_dim1 = ndim;

      omega = par[0];
      phi[0] = u[0];
      phi[1] = u[1];
      phi[2] = u[2];

      f[0] = 3.0*tan(phi[0])-omega*omega*(3.0*sin(phi[0])+2.0*sin(phi[1])+sin(
phi[2]));
      f[1] = 2.0*tan(phi[1])-omega*omega*(2.0*sin(phi[0])+2.0*sin(phi[1])+sin(
phi[2]));
      f[2] = tan(phi[2])-omega*omega*(sin(phi[0])+sin(phi[1])+sin(phi[2]));

      if (ijac == 0) {
          return 0;
      }

      /* Compute the Jacobian matrix. */

      jacob[0][0] = 3.0+3.0*pow(tan(phi[0]),2.0)-3.0*omega*omega*cos(phi[0]);
      jacob[0][1] = -2.0*omega*omega*cos(phi[1]);
      jacob[0][2] = -omega*omega*cos(phi[2]);
      jacob[1][0] = -2.0*omega*omega*cos(phi[0]);
      jacob[1][1] = 2.0+2.0*pow(tan(phi[1]),2.0)-2.0*omega*omega*cos(phi[1]);
      jacob[1][2] = -omega*omega*cos(phi[2]);
      jacob[2][0] = -omega*omega*cos(phi[0]);
      jacob[2][1] = -omega*omega*cos(phi[1]);
      jacob[2][2] = 1.0+pow(tan(phi[2]),2.0)-omega*omega*cos(phi[2]);
      ARRAY2D(dfdu,0,0) = jacob[0][0];
      ARRAY2D(dfdu,0,1) = jacob[0][1];
      ARRAY2D(dfdu,0,2) = jacob[0][2];
      ARRAY2D(dfdu,1,0) = jacob[1][0];
      ARRAY2D(dfdu,1,1) = jacob[1][1];
      ARRAY2D(dfdu,1,2) = jacob[1][2];
      ARRAY2D(dfdu,2,0) = jacob[2][0];
      ARRAY2D(dfdu,2,1) = jacob[2][1];
      ARRAY2D(dfdu,2,2) = jacob[2][2];

      if (ijac == 1) {
          return 0;
      }

      /* Compute the derivative of the vector field  */
      /* with respect to the parameters.             */

      dfdpar[0][0] = -2.0*omega*(3.0*sin(phi[0])+2.0*sin(phi[1])+sin(phi[2]));
      dfdpar[1][0] = -2.0*omega*(2.0*sin(phi[0])+2.0*sin(phi[1])+sin(phi[2]));
      dfdpar[2][0] = -2.0*omega*(sin(phi[0])+sin(phi[1])+sin(phi[2]));
      ARRAY2D(dfdp,0,0) = dfdpar[0][0];
      ARRAY2D(dfdp,1,0) = dfdpar[1][0];
      ARRAY2D(dfdp,2,0) = dfdpar[2][0];

      return 0;
}

/*--------------------------------------------------------------------------*/
/* STPNT  Gives a starting pointing                                         */
/*--------------------------------------------------------------------------*/

int stpnt(integer ndim, doublereal t,
          doublereal *u, doublereal *par)
{
      doublereal phi[3];
      doublereal omega;

      /* Change these values from 0.0 to the correct values! */

      /* Parameter values of the starting point */
      omega = 0.0;

      /* The starting point. */
      phi[0] = (doublereal) 0.0;
      phi[1] = (doublereal) 3.1415926535898;
      phi[2] = (doublereal) 0.0;

      par[0] = omega;
      u[0] = phi[0];
      u[1] = phi[1];
      u[2] = phi[2];
      return 0;
}

/*--------------------------------------------------------------------------*/
/* BCND  Defines the boundary conditions                                    */
/*--------------------------------------------------------------------------*/

int bcnd(integer ndim, const doublereal *par, const integer *icp,
         integer nbc, const doublereal *u0, const doublereal *u1, integer ijac,
         doublereal *fb, doublereal *dbc)
{
      return 0;
}

/*--------------------------------------------------------------------------*/
/* ICND  Defines the integral conditions                                    */
/*--------------------------------------------------------------------------*/

int icnd(integer ndim, const doublereal *par, const integer *icp,
         integer nint, const doublereal *u, const doublereal *uold,
         const doublereal *udot, const doublereal *upold, integer ijac,
         doublereal *fi, doublereal *dint)
{
      return 0;
}

/*--------------------------------------------------------------------------*/
/* FOPT                                                                     */
/*--------------------------------------------------------------------------*/

int fopt(integer ndim, const doublereal *u, const integer *icp,
         const doublereal *par, integer ijac,
         doublereal *fs, doublereal *dfdu, doublereal *dfdp)
{
      return 0;
}

/*--------------------------------------------------------------------------*/
/* PVLS                                                                     */
/*--------------------------------------------------------------------------*/

int pvls(integer ndim, const doublereal *u,
         doublereal *par)
{
      return 0;
}

/*--------------------------------------------------------------------------*/
